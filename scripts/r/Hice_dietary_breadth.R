if(interactive()==TRUE){
  library('here')
  library(ggplot2)
  library(tidyverse)
  library(ggridges)
  library(gridExtra)
  library(forcats)
  library(reshape2)
  library(corrplot)
  library(DataExplorer)
  library(ggpubr)
}else{
  library(here, lib.loc = '/data/home/btw863/r_packages/')
}

setwd(here())
source('scripts/r/r_network_gen.r')

field_data <- read.csv(here('data/Edited_all_files_with_lat_long_VKedits.csv'))
field_data$SiteAndYear <- paste(field_data$Site, field_data$Year, sep = ', ')
field_data$Faeces_no1 <- gsub('T', '', field_data$Faeces_no1)
field_data$Faeces_no2 <- gsub('T', '', field_data$Faeces_no2)
field_data_2 <- field_data
#The bit below deals with the inevitable merging issues with some samples being from faeces_no1, some from faeces_no2
field_data$Faeces_no2 <- NULL

field_data_2$Faeces_no1 <- field_data_2$Faeces_no2
field_data_2$Faeces_no2 <- NULL

field_data <- rbind(field_data, field_data_2)
all_interactions <- r_network_gen(collapse_species = F, desired_species = 'Hice', include_malua = T, lulu = T)
#all_interactions <- r_network_gen(collapse_species = F)
###Something is wrong with the data generated by all_interactions atm, the first column is empty

prey_data <- read.csv('data/taxonomy/order.csv')
colnames(prey_data) <- c('MOTU', 'Taxa')
prey_data$MOTU <- as.character(prey_data$MOTU)

# prey_data <- data.frame(rownames(all_interactions)[2:nrow(all_interactions)], sample(c('Lepidoptera','Diptera','Coleoptera'), nrow(all_interactions)-1, replace = T))


###Add the taxonomic information to the interactions for everything
taxa_mat <- all_interactions[1,]
z <- 2
for(i in 1: nrow(all_interactions)){
  rowname = rownames(all_interactions)[i]
  if(!rowname %in% prey_data$MOTU){
    next()
  }
  tax = as.character(prey_data[which(prey_data$MOTU == rowname),'Taxa'])
  if(is.null(nrow(taxa_mat))){ #If its the first iteration there won't be any rownames yet, so the next if statement will fail
    taxa_mat <- rbind(taxa_mat, all_interactions[i,])
    rownames(taxa_mat)[z] <- tax
    z <- z+1
  }
  if(tax %in% rownames(taxa_mat)){
    to_merge = which(rownames(taxa_mat)==tax)
    taxa_mat[to_merge,] <- taxa_mat[to_merge,]+ all_interactions[i,]
  }else{
    taxa_mat <- rbind(taxa_mat, all_interactions[i,])
    rownames(taxa_mat)[z] <- tax
    z <- z+1
  }
}
#The colnames currently have the sample numbers, we want them to be a useable value in the data frame
colnames(taxa_mat) <- taxa_mat[1,]
taxa_mat <- taxa_mat[-1,]

#####Make a list with a network for each site####

sites_list <- list()
sites <- unique(colnames(all_interactions))




for(i in 1:length(sites)){
  m =  all_interactions[,which(colnames(all_interactions )==sites[i])]
  colnames(m) = m[1,]
  m = m[-c(1,2),]
  m <- m[-which(rowSums(m)==0),]
  sites_list[[i]] <- m
}
print(sites)
names(sites_list) <- sites



#####Do some ecology ####
hice_ecology <- matrix(nrow=0, ncol=1+ncol(specieslevel(matrix(sample(0: 1, size =100, replace = T), nrow = 10, ncol = 10), level = 'higher')))

for(i in 1:length(sites_list)){
  starttime <- Sys.time()
  if(length(which(duplicated(colnames(sites_list[[i]]))))>0){
    sites_list[[i]] <- sites_list[[i]][,-which(duplicated(colnames(sites_list[[i]])))]
  }
  splevel = specieslevel(sites_list[[i]], level = 'higher')
  endtime <- Sys.time()
  cat(names(sites_list)[i],'took', endtime-starttime,'\n')
  hice_ecology <- rbind(hice_ecology, cbind(rep(names(sites_list)[i], nrow(splevel)), splevel))
}
hice_ecology <- cbind(rownames(hice_ecology), hice_ecology)
# write.csv(hice_ecology, 'hice_ecology_1.csv')
# hice_ecology <- read.csv('hice_ecology_1.csv')
#####Add some taxonomic information
colnames(hice_ecology)[c(1:2)] <- c('Sample','Site')
t_taxa <- t(taxa_mat)
t_taxa <- cbind(t_taxa, rownames(t_taxa))
t_taxa <- as.data.frame(t_taxa)
colnames(t_taxa)[ncol(t_taxa)] <- 'Sample_no'

hice_ecology <- merge(hice_ecology, t_taxa, by.x='Sample' , by.y= 'Sample_no')
# write.csv(hice_ecology, 'hice_ecology_2.csv')
# hice_ecology <- read.csv('hice_ecology_2.csv')
###Important: this doesn't include EVERY Hice sample, as some either have too many (or more likely too few) nodes for the analysis

hice_ecology <- merge(x = hice_ecology, y = field_data, by.x = 'Sample', by.y = 'Faeces_no1')

# write.csv(hice_ecology, 'hice_ecology_3.csv')
#####Work out the nestedness of each bat, then add it to the df#####


hice_ecology <- cbind(hice_ecology, rep(NA, nrow(hice_ecology)))
colnames(hice_ecology)[ncol(hice_ecology)] <- 'nestedrank'
for(n in 1:length(sites_list)){
  nest <- nestedrank(sites_list[[n]])[['higher level']]
  for(i in 1:length(nest)){
    if(names(nest)[i] %in% hice_ecology[,1]){
      val <- nest[i]
      print(val)
      pos <- which(hice_ecology[,1]==names(nest)[i])
      print(pos)
      hice_ecology[pos, ncol(hice_ecology)] <- val
    }
  }
}
# write.csv(hice_ecology, 'hice_ecology_4.csv')
save.image('data/output_data/hice_only_session')
write.csv(hice_ecology, 'data/output_data/hice_only_data.csv')
load('data/output_data/hice_only_session')
#####Make some graphs comparing sites and testing them with an anova ####
hice_ecology$SiteAndYear <- gsub('DVCA', 'DANUM', hice_ecology$SiteAndYear)
hice_ecology$habitat_type <- rep(NA, nrow(hice_ecology))
hice_ecology[grep('SAFE', hice_ecology$SiteAndYear), 'habitat_type'] <- 'Logged'
hice_ecology[grep('MALUA', hice_ecology$SiteAndYear), 'habitat_type'] <- 'Logged, replanted'
hice_ecology[grep('DANUM', hice_ecology$SiteAndYear), 'habitat_type'] <- 'Primary'
hice_ecology[grep('MALIAU', hice_ecology$SiteAndYear), 'habitat_type'] <- 'Primary'
hice_ecology$SiteAndYear <- gsub('MALIAU', 'Maliau', hice_ecology$SiteAndYear)
hice_ecology$SiteAndYear <- gsub('MALUA', 'SBE', hice_ecology$SiteAndYear)
hice_ecology$SiteAndYear <- gsub('DANUM', 'Danum', hice_ecology$SiteAndYear)
hice_ecology$SiteAndYear <- fct_rev(hice_ecology$SiteAndYear) #ggridges plots the factors in an annoying order, this rectifies it
hice_ecology$SiteYearAndSex <- paste(hice_ecology$SiteAndYear, hice_ecology$Sex)
colnames(hice_ecology) <- gsub('PDI', 'Resource range', colnames(hice_ecology)) #As the interactions are binary what we output was resource range, not PDI

 #Might be worth looking at normalised degree, closeness centrality, weighted.closeness , fisher.alpha, proportional.similarity, proportional.generality, d
 
# ridge <- ggplot(hice_ecology, aes (y=SiteAndYear, x =d, fill=habitat_type)) + 
#  geom_density_ridges(scale= 0.5)+ #The scale determines the space between the rows
#  theme_ridges()+ #This changes the theme to make it more aesthetically pleasing
#  scale_fill_cyclical(values = c("#85d7da","#cfb4de","#d0ca9f"), guide = 'legend', name = 'Habitat type')+
#  scale_x_continuous(expand = c(0.01, 0)) + #Make the space between the labels and plot smaller
#  scale_y_discrete(expand = c(0.01, 0))+ #Make it so the top series actually fits in the plot
#   ylab('Site and year')
  

# #The docs for ridgeplots are here https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html
# ridge
# pdf('plots/Site comparisons/normalised_degree_ridgeplot.pdf')
# ridge
# dev.off()

melted_hice <- melt(hice_ecology[,c('SiteAndYear', 'habitat_type', 'degree', 'normalised.degree', 'proportional.similarity', 'Resource range', 'Sex', 'Reproductive_condition', 'Age', 'Year', 'Site.y')],
                    id.vars = c('SiteAndYear', 'habitat_type', 'Sex', 'Reproductive_condition', 'Age', 'Site.y', 'Year'))
#The orders of the metrics aren't alphabetical, this alphabetises them and makes their names prettier
melted_hice$variable <- gsub('normalised.degree', 'Normalised degree', melted_hice$variable)
melted_hice$variable <- gsub('partner.diversity','Partner diversity', melted_hice$variable)
melted_hice$variable <- gsub('^degree$','Degree', melted_hice$variable)
melted_hice$variable <- gsub('proportional.similarity','Proportional similarity', melted_hice$variable)
melted_hice$variable <- gsub('PDI','Resource range', melted_hice$variable)
melted_hice$variable <- gsub('closeness','Closeness centrality', melted_hice$variable)
melted_hice$variable <- ordered(melted_hice$variable, levels=unique(melted_hice$variable)[order(as.character(unique(melted_hice$variable)))])


facet_ridge <- ggplot(melted_hice, aes (y=SiteAndYear, x =value, fill=habitat_type)) + 
  geom_density_ridges(scale= 0.5)+ #The scale determines the space between the rows
  theme_ridges()+ #This changes the theme to make it more aesthetically pleasing
  scale_fill_cyclical(values = c("#85d7da","#cfb4de","#d0ca9f"), guide = 'legend', name = 'Habitat type')+
  scale_x_continuous(expand = c(0.01, 0)) + #Make the space between the labels and plot smaller
  scale_y_discrete(expand = c(0.01, 0))+ #Make it so the top series actually fits in the plot
  ylab(NULL)+ xlab(NULL)+
  facet_wrap( ~ variable, ncol=1, scales = 'free_x', strip.position = 'bottom')+ #free_x is required so that the x-axes aren't all constrained to showing the same thing
  theme(strip.background = element_rect(fill="white"), strip.placement = "outside", panel.spacing = unit(0.8, "lines"),#strip stuff sorts the facet labels, spacing adjusts the space between facets
  axis.text.x = element_text(size=12),
  axis.text.y = element_text(size=12),
  text = element_text(size=12))+
  theme(legend.text =element_text(size = 10)) #Trying to standardise the sizes across both plots
facet_ridge

pdf('plots/Hice/facet_ridgeplot.pdf', width = 7, height = 12)
facet_ridge
dev.off()


#####Now comes the significance testing ####
anova_list <- list()
for(i in 1:length(unique(melted_hice$variable))){ #Could probably just use lapply now that a load of the loop has been killed
  v <- as.character(unique(melted_hice$variable)[i])
  s <- melted_hice[which(melted_hice$variable==v),]
  my_anova <- aov(s$value ~ s$SiteAndYear)
  summary(my_anova)
  anova_list[[i]] <- TukeyHSD(my_anova)
  names(anova_list)[i] <- v
}

mets <- c()
net1s <- c()
net2s <- c()
signif <- c()
for(l in 1:length(anova_list)){
  lis <- anova_list[[l]]$`s$SiteAndYear`
  for(i in 1:nrow(lis)){
    net1 <- strsplit(rownames(lis),split = '-')[[i]][1]
    net2 <- strsplit(rownames(lis),split = '-')[[i]][2]
    
    if(lis[i,4]<=0.05){
      sig <- 'significant difference'
    }else{sig <- 'non-significant'}
    
    net1s <- c(net1s, net1)
    net2s <- c(net2s, net2)
    mets <- c(mets, names(anova_list)[l])
    signif <- c(signif, sig)
  }
}
sig_df <- data.frame(as.factor(mets), as.factor(net1s), as.factor(net2s), as.factor(signif))
colnames(sig_df) <- c('metrics', 'network_1', 'network_2', 'significance')
# levels(sig_df$network_1) <- unique(melted_hice$SiteAndYear)
# levels(sig_df$network_2) <- unique(melted_hice$SiteAndYear)
# sig_df$network_1 <- ordered(melted_hice$SiteAndYear, levels=unique(melted_hice$variable)[order(as.character(unique(melted_hice$variable)))])
sig_df$network_2 <- fct_rev(sig_df$network_2) #ggridges plots the factors in an annoying order, this rectifies it

ultimate_plot <- ggplot(sig_df, aes(x = network_1, y = network_2)) +
  geom_tile(aes(fill=significance))+
  scale_fill_manual(values =c("white", "black"), na.value = 'white')+
  theme(panel.grid.major = element_blank(), panel.background = element_rect(fill= '#ededed', '#ededed'), panel.grid.minor = element_blank(),axis.text.x = element_text(angle = 90, hjust = 1),
        text = element_text(size=12))+
  ylab(NULL)+ xlab(NULL)+
  facet_wrap( ~ metrics, ncol=1, scales = 'free_x', strip.position = 'bottom')+ #free_x is required so that the x-axes aren't all constrained to showing the same thing
  theme(strip.background = element_rect(fill="white"), strip.placement = "outside", panel.spacing = unit(1.7, "lines"),#strip stuff sorts the facet labels, spacing adjusts the space between facets
        axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12))
ultimate_plot

pdf('plots/Hice/anova_outputs.pdf', width = 7, height = 12)
ultimate_plot
dev.off()

pdf('plots/Hice/grid.pdf', width = 12, height = 12)
grid.arrange(facet_ridge, ultimate_plot, nrow = 1)
dev.off()


melted_hice[which(!melted_hice$Age %in% c('A', 'J')), 'Age'] <- NA
melted_hice$Age <- as.factor(melted_hice$Age)
melted_hice[which(!melted_hice$Sex %in% c('M', 'F')), 'Sex'] <- NA
melted_hice$Sex <- factor(melted_hice$Sex)
melted_hice$Reproductive_condition <- gsub("LA", "L", melted_hice$Reproductive_condition)
melted_hice[which(!melted_hice$Reproductive_condition %in% c('L', 'PL', 'PR')), 'Reproductive_condition'] <- 'NR'
melted_hice$Site.y <- gsub('DVCA', 'DANUM', melted_hice$Site.y)
melted_hice$Reproductive_condition <- factor(melted_hice$Reproductive_condition)
melted_hice$Site.y <- factor(melted_hice$Site.y)
melted_hice$Year <- factor(melted_hice$Year)
mets <- c('Degree', "Normalised degree", 'Resource range', 'Proportional similarity')
 
 
for(i in 1:length(mets)){
 met = mets[i]
 mod <- lm(value ~ Sex + Age + Reproductive_condition + Year + habitat_type,  data = melted_hice[which(melted_hice$variable==mets[i]),])
 temp_df <- hice_ecology[which(!is.na(hice_ecology$Sex)),]
 sink(paste('data/output_data/hice_stats/', met, '.txt', sep = ''))
 print(summary(mod))
 sink()
}

melted_degree <- melted_hice[which(melted_hice$variable=='Degree'),]

#1-off ANOVA on degree
fit_both_sexes <- lm(log(value) ~ Sex + Age + Year +  Site.y, data = melted_degree)
fitrep <- lm(log(value) ~Year + Site.y + Reproductive_condition,  data = melted_degree[which(melted_degree$Sex=='F'),])
anova(fit1, fit2)


 

####Look at correlations ####

taxa_for_cor <- t(taxa_mat)
cormat <- round(cor(taxa_for_cor),2)
res1 <- cor.mtest(taxa_mat, conf.level = .95)



###Here we use pearsons similarity to plot only the significantly correlated points, 
#ordered along the angular order of the eigenvectors
pdf('plots/Hice/taxa_correlations.pdf')
taxa_corr <- corrplot(cormat, method = "circle", p.mat = res1$p, sig.level = .05, type = 'upper', order = 'AOE',
                      tl.col = "black", tl.srt = 45, insig = 'blank',
                      bg = "black")
                       
dev.off()


hice_stats <- hice_ecology[,seq(4,22)]
#I get rid of these values here as they never change and so are worthless for this
hice_stats <- hice_stats[,-which(colnames(hice_stats) %in% c("node.specialisation.index.NSI", "betweenness", "weighted.betweenness"))]

hice_cor <- round(cor(hice_stats),2)
stat_sig <- cor.mtest(hice_stats, conf.level = .95)


pdf('plots/Hice/metric_correlations.pdf')
corrplot(hice_cor, method = "circle", p.mat = stat_sig$p, sig.level = .05, type = 'upper', order = 'AOE',
         tl.col = "black", tl.srt = 45, insig = 'blank')

dev.off()




tax_df <- hice_ecology[,c(1, 73, seq(23,39))]
tax_df <- melt(tax_df, id.vars = c('Sample', 'SiteAndYear'))
colnames(tax_df)[c(3,4)] <- c('Order', 'Present/absent')
tax_df$`Present/absent` <- as.integer(as.character(tax_df$`Present/absent`))
tax_df$`Present/absent` <- ifelse(tax_df$`Present/absent`== 0, 0, 1)

prop_present <- sapply(unique(tax_df[,c('SiteAndYear', 'Order')]),  function(x) as.character(x))
prop <- c()
nbats <- c()
#for(i in 1: 1){
for(i in 1: nrow(prop_present)){
  tem <- tax_df[which(tax_df$SiteAndYear== as.character(prop_present[i,1])
                      & tax_df$Order==as.character(prop_present[i,2])),]
  prop <- c(prop, sum(tem$`Present/absent`)/nrow(tem)) #The number of bats that consumed the order, divided by total bats
  nbats <- c(nbats, nrow(tem))
}


prop_present <- cbind(prop_present, prop, nbats)
prop_present <- as.data.frame(prop_present)
prop_present$prop <- as.numeric(as.character(prop_present$prop))
prop_present$nbats <- as.integer(as.character(prop_present$nbats))

prop_present$SiteAndYear <- gsub('DANUM', 'Danum', prop_present$SiteAndYear)
prop_present$SiteAndYear <- gsub('DVCA', 'Danum', prop_present$SiteAndYear)
prop_present$SiteAndYear <- gsub('MALIAU', 'Maliau', prop_present$SiteAndYear)


tiles <- ggplot(data = prop_present, aes(y = fct_rev(Order), x =SiteAndYear)) + geom_tile(aes(fill=prop), colour = 'white')+
  scale_fill_gradient2(low = "white", mid = "blue",
                       high = "black", midpoint = 0.5, name = 'Proportion', limits = c(0,1)) + 
  labs(fill='Proportion of MOTU present',
       x ="Site and year", y = 'Prey order')+
  theme(panel.background=element_blank(), axis.text.x = element_text(angle = 90, hjust = 1))
tiles

pdf('plots/Hice/proportion_of_individuals_containing.pdf')
tiles
dev.off()

#####A bit of repairing dodgy field data entry#####

hice_ecology$Sex <- gsub('0', 'Unknown', hice_ecology$Sex)
hice_ecology$Sex <- gsub('J', 'Unknown', hice_ecology$Sex)
hice_ecology$Age <- gsub('0', 'Unknown', hice_ecology$Age)
hice_ecology$Age <- gsub('UNK', 'Unknown', hice_ecology$Age)
hice_ecology$Reproductive_condition <- gsub('^P$', 'PR', hice_ecology$Reproductive_condition)
hice_ecology$Reproductive_condition <- gsub('^L$', 'LA', hice_ecology$Reproductive_condition)
hice_ecology$Reproductive_condition <- gsub('UNKNOWN', NA, hice_ecology$Reproductive_condition)
hice_ecology$Reproductive_condition <- gsub('0', NA, hice_ecology$Reproductive_condition)



#Make a density plot of the metrics and sexes
for_model <- melted_hice[which(melted_hice$Sex!= 'Unknown'),]
# sexlist <- list()
# for(i in 1:length(unique(for_model$variable))){
#   sexlist[[i]] <- ggplot(for_model[which(for_model$variable==unique(for_model$variable)[i]),], aes(value, fill = fct_rev(Sex)))+ geom_density(alpha = 0.3)+ 
#     facet_wrap(variable ~ fct_rev(SiteAndYear), ncol = 8)+scale_fill_manual(values=c("yellow","#01c2cd"), name = 'Sex')+
#     theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
#                        panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),strip.background =element_rect(fill="black"),strip.text = element_text(colour = 'white'))+
#     labs(y='Density', x = NULL)
#   
# }
# 
# ggarrange(sexlist[[1]], sexlist[[2]], sexlist[[3]], sexlist[[4]], ncol=1, nrow =4,  common.legend = TRUE, legend="right")
# pdf('plots/Hice/sex_comparisons.pdf', width=12)
# ggarrange(sexlist[[1]], sexlist[[2]], sexlist[[3]], sexlist[[4]], ncol=1, nrow =4,  common.legend = TRUE, legend="right")
# dev.off()
# 
# sex_degreeplot <- ggplot(for_model[which(for_model$variable=='Degree'),], aes(value, fill = fct_rev(Sex)))+ geom_density(alpha = 0.3)+ 
#   facet_wrap(habitat_type~ fct_rev(SiteAndYear), ncol = 4)+scale_fill_manual(values=c("yellow","#01c2cd"), name = 'Sex')+
#   theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
#                      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),strip.background =element_rect(fill="black"),strip.text = element_text(colour = 'white'))+
#   labs(y='Density', x = 'Degree')
# sex_degreeplot
# pdf('plots/Hice/degree_sex.pdf')
# sex_degreeplot
# dev.off()
# 

degree <- for_model[which(for_model$variable=='Degree'),]
#1-off ANOVA on degree
fit_both_sexes_1 <- lm(log(value) ~ Sex + Age + Year +  Site.y, data = degree)
fit_both_sexes_2 <- lm(log(value) ~ Sex + Age + Year +  habitat_type, data = degree) #this one has a slightly better f-statistic but a slightly lower r-squared
fitrep <- lm(log(value) ~Year + Site.y + Reproductive_condition,  data = degree[which(degree$Sex=='F'),])


ggplot(degree[which(degree$Sex=='F' & degree$Reproductive_condition %in% c('PL', 'NR')),], aes(value, fill = fct_rev(Reproductive_condition)))+ geom_density(alpha = 0.3)+ 
     facet_wrap(habitat_type~ fct_rev(SiteAndYear), ncol = 4)+scale_fill_manual(values=c("yellow","#01c2cd", 'blue', 'green'), name = 'Sex')+
     theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),strip.background =element_rect(fill="black"),strip.text = element_text(colour = 'white'))+
     labs(y='Density', x = 'Degree')

